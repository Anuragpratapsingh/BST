// Following is the Binary Tree node structure
/**************
class BinaryTreeNode {
    public : 
    T data;
    BinaryTreeNode<T> *left;
    BinaryTreeNode<T> *right;

    BinaryTreeNode(T data) {
        this -> data = data;
        left = NULL;
        right = NULL;
    }
};
***************/
BinaryTreeNode<int>* searchInBST(BinaryTreeNode<int> *root , int k){
    /* Don't write main().
     * Don't read input, it is passed as function argument.
     * Return output and don't print it.
     * Taking input and printing output is handled automatically.
     */
    if(root==NULL)
    {
        return NULL;
    }
    if(root->data==k)
    {
        return root;
    }
    if(root->data>k)
    {
        return searchInBST(root->left,k);
    }
    else if(root->data<k)
    {
        return searchInBST(root->right,k);
    }
}
int getMax(BinaryTreeNode<int>*root)
{
    if(root==NULL)
    {
        return INT_MIN;
    }
    return max(root->data,max(getMax(root->left),getMax(root->right)));
}
int getMin(BinaryTreeNode<int>*root)
{
    
    if(root==NULL)
    {
        return INT_MAX;
    }
    return min(root->data,min(getMin(root->left),getMin(root->right)));
}
bool isBST1(BinaryTreeNode<int> *root){
    //Have to check root data with the max of left subtree and min of right subtree
    //But complexity bad as har baar max min and isBST nikalna padh raha
    if(root==NULL)
    {
        return true;
    }
    int maxi=getMax(root->left);
    int mini=getMin(root->right);
    bool left=isBST1(root->left);
    bool right=isBST1(root->right);
    if(root->data>maxi&&root->data<=mini&&left&&right)
    {
        return true;
    }
    else 
    {
        return false;
    }
}
class isBSTreturn
{
    public:
    bool isBST;
    int maximum;
    int minimum;
};
isBSTreturn isBST2(BinaryTreeNode<int>*root)
{
    if(root==NULL)
    {
        isBSTreturn output;
        output.isBST=true;
        output.maximum=INT_MIN;
        output.minimum=INT_MAX;
        return output;
    }
    isBSTreturn left=isBST2(root->left);
    isBSTreturn right=isBST2(root->right);
    int maxi=max(root->data,max(left.maximum,right.maximum));
    int mini=min(root->data,min(left.minimum,right.minimum));
    isBSTreturn answer;
    answer.maximum=maxi;
    answer.minimum=mini;
    answer.isBST=root->data>mini&&root->data<=maxi&&left.isBST&&right.isBST;
    return answer;
}
bool isBst3(BinaryTreeNode<int>*root,int max=INT_MAX,int min=INT_MIN)
{
    //See nb for explaination
    if(root==NULL)
    {
        return true;
    }
    if(root->data<min || root->data>max)
    {
        return false;
    }
    bool isLeft=isBst3(root->left,root->data-1,min);
    bool isRight=isBst3(root->right,max,root->data);
    return isLeft&&isRight;
}

void elementsInRangeK1K2(BinaryTreeNode<int>* root, int k1, int k2) {
    /* Don't write main().
     * Don't read input, it is passed as function argument.
     * Print output and don't return it.
     * Taking input is handled automatically.
     */
    if(root==NULL)
    {
        return;
    }
    if(root->data>=k1 && root->data<=k2)
    {
        elementsInRangeK1K2(root->left,k1,k2);
        //As want to print in ascending order answers tabhi pehle left then root then right print
        cout<<root->data<<" ";
        elementsInRangeK1K2(root->right,k1,k2);
    }
    if(root->data<k1)
    {
      //Then left mei toh k1 se bhi chote honge
         elementsInRangeK1K2(root->right,k1,k2);
    }
    if(root->data>k2)
    {
        //Right mei k2 se bhi bade honge
        elementsInRangeK1K2(root->left,k1,k2);
    }
}
